<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<canvas width="500" height="500"></canvas>

<script type="module">
  import { GLShader } from '../../lib/gl-tool.js'

  class Triangle {
    constructor (config) {
      this.u_color = config.color || [Math.random(), Math.random(), Math.random(), 1.0]
      this.u_rotation = config.rotation || Math.random() * Math.PI
      this.u_time = config.time || 0
      this.u_scale = config.scale || Math.random * 0.05 + 0.05
      this.u_duration = config.duration || 3.0
      const rad = Math.random() * Math.PI * 2
      this.u_dir = config.dir || [Math.cos(rad), Math.sin(rad)]  // 向量方向
      this.startTime = performance.now()
    }
  }

  function draw (gl) {
    const points = new Float32Array([-1, 1, -1,-1,  1,-1, 1,1])
    const shader = new GLShader(gl, {
      points
    })
    shader.shader = {
      vertex: `
            attribute vec2 position;
            uniform float u_rotation;
            uniform float u_time;
            uniform float u_duration;
            uniform float u_scale;
            uniform vec2 u_dir;

            varying float vP;
            void main() {
                float p = min(1.0, u_time / u_duration);
                float rad = u_rotation + 3.14 * 10.0 * p;
                float scale = u_scale * p * (2.0 - p);
                vec2 offset = 2.0 * u_dir * p * p;
                mat3 translateMatrix = mat3(
                    1.0, 0.0, 0.0,
                    0.0, 1.0, 0.0,
                    offset.x, offset.y, 1.0
                );
                mat3 rotateMatrix = mat3(
                    cos(rad), sin(rad), 0.0,
                    -sin(rad), cos(rad), 0.0,
                    0.0, 0.0, 1.0
                );
                mat3 scaleMatrix = mat3(
                    scale, 0.0, 0.0,
                    0.0, scale, 0.0,
                    0.0, 0.0, 1.0
                );
                gl_Position = 1.0;
                vec3 pos = translateMatrix * rotateMatrix * scaleMatrix * vec3(position, 1.0);
                gl_Position = vec4(pos, 1.0);
                vP = p;
            }`,
      fragment: `
            precision mediump float;
            varying vec4 u_color;
            varying float vP;

            void main() {
                gl_FragColor.xyz = u_color.xyz;
                gl_FragColor.a = (1.0 - vP) * u_color.a
            }`,
    }
    shader.createProgram()

    // 缓冲区
    shader.bindBuffer()

    // 将数据读取至GPU
    shader.enableVertex()

    // 绘制
    gl.clear(gl.COLOR_BUFFER_BIT)
    gl.drawArrays(gl.TRIANGLE_FAN, 0, points.length / 2)
    requestAnimationFrame(() => draw(gl, rate, color))
  }
  {
    const canvas = document.querySelector('canvas')
    const gl = canvas.getContext('webgl')
    requestAnimationFrame(() => draw(gl))
  }
</script>
</body>
</html>
